<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenCV: Contour Features</title>
<link href="opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">3.2.0-dev</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<script type="text/javascript">
//<![CDATA[
function getLabelName(innerHTML) {
    var str = innerHTML.toLowerCase();
    // Replace all '+' with 'p'
    str = str.split('+').join('p');
    // Replace all ' ' with '_'
    str = str.split(' ').join('_');
    // Replace all '#' with 'sharp'
    str = str.split('#').join('sharp');
    // Replace other special characters with 'ascii' + code
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (!(charCode == 95 || (charCode > 96 && charCode < 123) || (charCode > 47 && charCode < 58)))
            str = str.substr(0, i) + 'ascii' + charCode + str.substr(i + 1);
    }
    return str;
}
function addToggle() {
    var $getDiv = $('div.newInnerHTML').last();
    var buttonName = $getDiv.html();
    var label = getLabelName(buttonName.trim());
    $getDiv.attr("title", label);
    $getDiv.hide();
    $getDiv = $getDiv.next();
    $getDiv.attr("class", "toggleable_div label_" + label);
    $getDiv.hide();
}
//]]>
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="tutorial_js_root.html">OpenCV.js Tutorials</a></li><li class="navelem"><a class="el" href="tutorial_js_table_of_contents_imgproc.html">Image Processing</a></li><li class="navelem"><a class="el" href="tutorial_js_table_of_contents_contours.html">Contours in OpenCV</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Contour Features </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Goal </h2>
<p>In this article, we will learn</p>
<ul>
<li>To find the different features of contours, like area, perimeter, centroid, bounding box etc</li>
<li>You will see plenty of functions related to contours.</li>
</ul>
<h2>1. Moments </h2>
<p>Image moments help you to calculate some features like center of mass of the object, area of the object etc. Check out the wikipedia page on <a href="http://en.wikipedia.org/wiki/Image_moment">Image Moments</a></p>
<p>We use the function: <b><a class="el" href="d3/dc0/group__imgproc__shape.html#ga556a180f43cab22649c23ada36a8a139" title="Calculates all of the moments up to the third order of a polygon or rasterized shape. ">cv.moments</a> (array, binaryImage = false)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>raster image (single-channel, 8-bit or floating-point 2D array) or an array ( 1×N or N×1 ) of 2D points. </td></tr>
    <tr><td class="paramname">binaryImage</td><td>if it is true, all non-zero image pixels are treated as 1's. The parameter is used for images only.</td></tr>
  </table>
  </dd>
</dl>
<h2>Try it </h2>
<p>Here is a demo. Canvas elements named momentsCanvasInput have been prepared. Choose an image and click <code>Try it</code> to see the result. And you can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
<style>
canvas {
    border: 1px solid black;
}
.err {
    color: red;
}
</style>
</head>
<body>
<div id="momentsCodeArea">
<h2>Input your code</h2>
<button id="momentsTryIt" disabled="true" onclick="momentsExecuteCode()">Try it</button><br>
<textarea rows="12" cols="90" id="momentsTestCode" spellcheck="false">
var src = cv.imread("momentsCanvasInput");
var dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);
cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
cv.threshold(src, src, 177, 200, cv.THRESH_BINARY);
var contours  = new cv.MatVector();
var hierarchy = new cv.Mat();
cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE, [0,0]);
// You can try more different conversion
var M = cv.moments(contours.get(0), false);
momentsOutput.innerHTML = M.m00;
src.delete(); dst.delete(); contours.delete(); hierarchy.delete(); 
M.delete();
</textarea>
<p class="err" id="momentsErr"></p>
</div>
<div id="momentsShowcase">
    <div>
        <canvas id="momentsCanvasInput"></canvas>
    </div>
    <input type="file" id="momentsInput" name="file" />
    <p><strong>The m00 is: </strong><span id="momentsOutput"></span></p>
</div>
<script src="utils.js"></script>
<script async src="opencv.js" id="opencvjs"></script>
<script>
var momentsOutput = document.getElementById("momentsOutput");
function momentsExecuteCode() {
    var momentsText = document.getElementById("momentsTestCode").value;
    try {
        eval(momentsText);
        document.getElementById("momentsErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("momentsErr").innerHTML = err;
    }
}

loadImageToCanvas("lena.jpg", "momentsCanvasInput");
var momentsInputElement = document.getElementById("momentsInput");
momentsInputElement.addEventListener("change", momentsHandleFiles, false);
function momentsHandleFiles(e) {
    var momentsUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(momentsUrl, "momentsCanvasInput");
}
</script>
</body>
</p>
<p>From this moments, you can extract useful data like area, centroid etc. Centroid is given by the relations, \(C_x = \frac{M_{10}}{M_{00}}\) and \(C_y = \frac{M_{01}}{M_{00}}\). This can be done as follows: </p><div class="fragment"><div class="line">var cx = M.m10/M.m00</div><div class="line">var cy = M.m01/M.m00</div></div><!-- fragment --><h2>2. Contour Area </h2>
<p>Contour area is given by the function <b><a class="el" href="d3/dc0/group__imgproc__shape.html#ga2c759ed9f497d4a618048a2f56dc97f1" title="Calculates a contour area. ">cv.contourArea()</a></b> or from moments, <b>M['m00']</b>.</p>
<p>We use the function: <b><a class="el" href="d3/dc0/group__imgproc__shape.html#ga2c759ed9f497d4a618048a2f56dc97f1" title="Calculates a contour area. ">cv.contourArea</a> (contour, oriented = false)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contour</td><td>input vector of 2D points (contour vertices) </td></tr>
    <tr><td class="paramname">oriented</td><td>oriented area flag. If it is true, the function returns a signed area value, depending on the contour orientation (clockwise or counter-clockwise). Using this feature you can determine orientation of a contour by taking the sign of an area. By default, the parameter is false, which means that the absolute value is returned.</td></tr>
  </table>
  </dd>
</dl>
<h2>Try it </h2>
<p>Here is a demo. Canvas elements named areaCanvasInput have been prepared. Choose an image and click <code>Try it</code> to see the result. And you can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
<style>
canvas {
    border: 1px solid black;
}
</style>
</head>
<body>
<div id="areaCodeArea">
<h2>Input your code</h2>
<button id="areaTryIt" disabled="true" onclick="areaExecuteCode()">Try it</button><br>
<textarea rows="12" cols="90" id="areaTestCode" spellcheck="false">
var src = cv.imread("areaCanvasInput");
var dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);
cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
cv.threshold(src, src, 177, 200, cv.THRESH_BINARY);
var contours  = new cv.MatVector();
var hierarchy = new cv.Mat();
cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE, [0,0]);
// You can try more different conversion
var area = cv.contourArea(contours.get(20), false);
areaOutput.innerHTML = area;
src.delete(); dst.delete(); contours.delete(); hierarchy.delete();
</textarea>
<p class="err" id="areaErr"></p>
</div>
<div id="areaShowcase">
    <div>
        <canvas id="areaCanvasInput"></canvas>
    </div>
    <input type="file" id="areaInput" name="file" />
    <p><strong>The area is: </strong><span id="areaOutput"></span></p>
</div>
<script>
var areaOutput = document.getElementById("areaOutput");
function areaExecuteCode() {
    var areaText = document.getElementById("areaTestCode").value;
    try {
        eval(areaText);
        document.getElementById("areaErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("areaErr").innerHTML = err;
    }
}

loadImageToCanvas("lena.jpg", "areaCanvasInput");
var areaInputElement = document.getElementById("areaInput");
areaInputElement.addEventListener("change", areaHandleFiles, false);
function areaHandleFiles(e) {
    var areaUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(areaUrl, "areaCanvasInput");
}
</script>
</body>
</p>
<h2>3. Contour Perimeter </h2>
<p>It is also called arc length. It can be found out using <b><a class="el" href="d3/dc0/group__imgproc__shape.html#ga8d26483c636be6b35c3ec6335798a47c" title="Calculates a contour perimeter or a curve length. ">cv.arcLength()</a></b> function.</p>
<p>We use the function: <b><a class="el" href="d3/dc0/group__imgproc__shape.html#ga8d26483c636be6b35c3ec6335798a47c" title="Calculates a contour perimeter or a curve length. ">cv.arcLength</a> (curve, closed)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curve</td><td>input vector of 2D points. </td></tr>
    <tr><td class="paramname">closed</td><td>flag indicating whether the curve is closed or not.</td></tr>
  </table>
  </dd>
</dl>
<h2>Try it </h2>
<p>Here is a demo. Canvas elements named perimeterCanvasInput have been prepared. Choose an image and click <code>Try it</code> to see the result. And you can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
<style>
canvas {
    border: 1px solid black;
}
</style>
</head>
<body>
<div id="perimeterCodeArea">
<h2>Input your code</h2>
<button id="perimeterTryIt" disabled="true" onclick="perimeterExecuteCode()">Try it</button><br>
<textarea rows="12" cols="90" id="perimeterTestCode" spellcheck="false">
var src = cv.imread("perimeterCanvasInput");
var dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);
cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
cv.threshold(src, src, 177, 200, cv.THRESH_BINARY);
var contours  = new cv.MatVector();
var hierarchy = new cv.Mat();
cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE, [0,0]);
// You can try more different conversion
var perimeter = cv.arcLength(contours.get(20), true);
perimeterOutput.innerHTML = perimeter;
src.delete(); dst.delete(); contours.delete(); hierarchy.delete(); 
</textarea>
<p class="err" id="perimeterErr"></p>
</div>
<div id="perimeterShowcase">
    <div>
        <canvas id="perimeterCanvasInput"></canvas>
    </div>
    <input type="file" id="perimeterInput" name="file" />
    <p><strong>The perimeter is: </strong><span id="perimeterOutput"></span></p>
</div>
<script>
var perimeterOutput = document.getElementById("perimeterOutput");
function perimeterExecuteCode() {
    var perimeterText = document.getElementById("perimeterTestCode").value;
    try {
        eval(perimeterText);
        document.getElementById("perimeterErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("perimeterErr").innerHTML = err;
    }
}

loadImageToCanvas("lena.jpg", "perimeterCanvasInput");
var perimeterInputElement = document.getElementById("perimeterInput");
perimeterInputElement.addEventListener("change", perimeterHandleFiles, false);
function perimeterHandleFiles(e) {
    var perimeterUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(perimeterUrl, "perimeterCanvasInput");
}
</script>
</body>
</p>
<h2>4. Contour Approximation </h2>
<p>It approximates a contour shape to another shape with less number of vertices depending upon the precision we specify. It is an implementation of <a href="http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm">Douglas-Peucker algorithm</a>. Check the wikipedia page for algorithm and demonstration.</p>
<p>We use the function: <b><a class="el" href="d3/dc0/group__imgproc__shape.html#ga0012a5fdaea70b8a9970165d98722b4c" title="Approximates a polygonal curve(s) with the specified precision. ">cv.approxPolyDP</a> (curve, approxCurve, epsilon, closed)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curve</td><td>input vector of 2D points stored in <a class="el" href="d3/d63/classcv_1_1Mat.html" title="n-dimensional dense array class ">cv.Mat</a>. </td></tr>
    <tr><td class="paramname">approxCurve</td><td>result of the approximation. The type should match the type of the input curve. </td></tr>
    <tr><td class="paramname">epsilon</td><td>parameter specifying the approximation accuracy. This is the maximum distance between the original curve and its approximation. </td></tr>
    <tr><td class="paramname">closed</td><td>If true, the approximated curve is closed (its first and last vertices are connected). Otherwise, it is not closed.</td></tr>
  </table>
  </dd>
</dl>
<h2>Try it </h2>
<p>Here is a demo. Canvas elements named approxPolyDPCanvasInput and approxPolyDPCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. And you can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
<style>
canvas {
    border: 1px solid black;
}
</style>
</head>
<body>
<div id="approxPolyDPCodeArea">
<h2>Input your code</h2>
<button id="approxPolyDPTryIt" disabled="true" onclick="approxPolyDPExecuteCode()">Try it</button><br>
<textarea rows="20" cols="90" id="approxPolyDPTestCode" spellcheck="false">
var src = cv.imread("approxPolyDPCanvasInput");
var dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);
cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
cv.threshold(src, src, 100, 200, cv.THRESH_BINARY);
var contours  = new cv.MatVector();
var hierarchy = new cv.Mat();
var poly = new cv.MatVector();
cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE, [0,0]);
// approximates each contour to polygon
for(var i = 0 ; i < contours.size(); ++i)
{
    let tmp = new cv.Mat();
    // You can try more different conversion
    cv.approxPolyDP(contours.get(i), tmp, 3, true);
    poly.push_back(tmp);
}
// draw contours with random Scalar
for(var i = 0 ; i < contours.size(); ++i)
{
    var color = new cv.Scalar(Math.round(Math.random() * 255), Math.round(Math.random() * 255), Math.round(Math.random() * 255));
    cv.drawContours( dst, poly, i, color, 1, 8, hierarchy, 0, [0,0]);
    color.delete();
}
cv.imshow("approxPolyDPCanvasOutput", dst);
src.delete(); dst.delete(); hierarchy.delete(); contours.delete(); poly.delete();
</textarea>
<p class="err" id="approxPolyDPErr"></p>
</div>
<div id="approxPolyDPShowcase">
    <div>
        <canvas id="approxPolyDPCanvasInput"></canvas>
        <canvas id="approxPolyDPCanvasOutput"></canvas>
    </div>
    <input type="file" id="approxPolyDPInput" name="file" />
</div>
<script>
function approxPolyDPExecuteCode() {
    var approxPolyDPText = document.getElementById("approxPolyDPTestCode").value;
    try {
        eval(approxPolyDPText);
        document.getElementById("approxPolyDPErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("approxPolyDPErr").innerHTML = err;
    }
}

loadImageToCanvas("lena.jpg", "approxPolyDPCanvasInput");
var approxPolyDPInputElement = document.getElementById("approxPolyDPInput");
approxPolyDPInputElement.addEventListener("change", approxPolyDPHandleFiles, false);
function approxPolyDPHandleFiles(e) {
    var approxPolyDPUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(approxPolyDPUrl, "approxPolyDPCanvasInput");
}
</script>
</body>
</p>
<h2>5. Convex Hull </h2>
<p>Convex Hull will look similar to contour approximation, but it is not (Both may provide same results in some cases). Here, <b><a class="el" href="d3/dc0/group__imgproc__shape.html#ga014b28e56cb8854c0de4a211cb2be656" title="Finds the convex hull of a point set. ">cv.convexHull()</a></b> function checks a curve for convexity defects and corrects it. Generally speaking, convex curves are the curves which are always bulged out, or at-least flat. And if it is bulged inside, it is called convexity defects. For example, check the below image of hand. Red line shows the convex hull of hand. The double-sided arrow marks shows the convexity defects, which are the local maximum deviations of hull from contours.</p>
<div class="image">
<img src="convexitydefects.jpg" alt="convexitydefects.jpg"/>
<div class="caption">
image</div></div>
<p> We use the function: <b><a class="el" href="d3/dc0/group__imgproc__shape.html#ga014b28e56cb8854c0de4a211cb2be656" title="Finds the convex hull of a point set. ">cv.convexHull</a> (points, hull, clockwise = false, returnPoints = true)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input 2D point set. </td></tr>
    <tr><td class="paramname">hull</td><td>output convex hull. </td></tr>
    <tr><td class="paramname">clockwise</td><td>orientation flag. If it is true, the output convex hull is oriented clockwise. Otherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing to the right, and its Y axis pointing upwards. </td></tr>
    <tr><td class="paramname">returnPoints</td><td>operation flag. In case of a matrix, when the flag is true, the function returns convex hull points. Otherwise, it returns indices of the convex hull points.</td></tr>
  </table>
  </dd>
</dl>
<h2>Try it </h2>
<p>Here is a demo. Canvas elements named convexHullCanvasInput and convexHullCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. And you can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
<style>
canvas {
    border: 1px solid black;
}
</style>
</head>
<body>
<div id="convexHullCodeArea">
<h2>Input your code</h2>
<button id="convexHullTryIt" disabled="true" onclick="convexHullExecuteCode()">Try it</button><br>
<textarea rows="24" cols="90" id="convexHullTestCode" spellcheck="false">
var src = cv.imread("convexHullCanvasInput");
var dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);
cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
cv.threshold(src, src, 100, 200, cv.THRESH_BINARY);
var contours  = new cv.MatVector();
var hierarchy = new cv.Mat();
var hull = new cv.MatVector();
cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE, [0,0]);
// approximates each contour to convex hull
for(var i = 0 ; i < contours.size(); ++i)
{
    // You can try more different conversion
    let tmp = new cv.Mat();
    cv.convexHull(contours.get(i), tmp, false, true);
    hull.push_back(tmp);
}
// draw contours with random Scalar
for(var i = 0 ; i < contours.size(); ++i)
{
    var colorHull = new cv.Scalar(Math.round(Math.random() * 255), Math.round(Math.random() * 255), Math.round(Math.random() * 255));
    cv.drawContours(dst, hull, i, colorHull, 1, 8, hierarchy, 0, [0,0]);
    var colorContours = new cv.Scalar(Math.round(Math.random() * 255), Math.round(Math.random() * 255), Math.round(Math.random() * 255));
    colorHull.delete(); colorContours.delete();
}
cv.imshow("convexHullCanvasOutput", dst);
src.delete(); dst.delete(); hierarchy.delete(); contours.delete(); hull.delete();
</textarea>
<p class="err" id="convexHullErr"></p>
</div>
<div id="convexHullShowcase">
    <div>
        <canvas id="convexHullCanvasInput"></canvas>
        <canvas id="convexHullCanvasOutput"></canvas>
    </div>
    <input type="file" id="convexHullInput" name="file" />
</div>
<script>
function convexHullExecuteCode() {
    var convexHullText = document.getElementById("convexHullTestCode").value;
    try {
        eval(convexHullText);
        document.getElementById("convexHullErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("convexHullErr").innerHTML = err;
    }
}

loadImageToCanvas("lena.jpg", "convexHullCanvasInput");
var convexHullInputElement = document.getElementById("convexHullInput");
convexHullInputElement.addEventListener("change", convexHullHandleFiles, false);
function convexHullHandleFiles(e) {
    var convexHullUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(convexHullUrl, "convexHullCanvasInput");
}
</script>
</body>
</p>
<h2>6. Checking Convexity </h2>
<p>There is a function to check if a curve is convex or not, <b><a class="el" href="d3/dc0/group__imgproc__shape.html#ga8abf8010377b58cbc16db6734d92941b" title="Tests a contour convexity. ">cv.isContourConvex()</a></b>. It just return whether True or False. Not a big deal.</p>
<div class="fragment"><div class="line"><a class="code" href="d2/d75/namespacecv.html">cv</a>.isContourConvex(contours.get(i));</div></div><!-- fragment --><h2>7. Bounding Rectangle </h2>
<p>There are two types of bounding rectangles.</p>
<h3>7.a. Straight Bounding Rectangle</h3>
<p>It is a straight rectangle, it doesn't consider the rotation of the object. So area of the bounding rectangle won't be minimum.</p>
<p>We use the function: <b><a class="el" href="d3/dc0/group__imgproc__shape.html#gacb413ddce8e48ff3ca61ed7cf626a366" title="Calculates the up-right bounding rectangle of a point set. ">cv.boundingRect</a> (points)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input 2D point set.</td></tr>
  </table>
  </dd>
</dl>
<h2>Try it </h2>
<p>Here is a demo. Canvas elements named boundingRectCanvasInput and boundingRectCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. And you can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
<style>
canvas {
    border: 1px solid black;
}
</style>
</head>
<body>
<div id="boundingRectCodeArea">
<h2>Input your code</h2>
<button id="boundingRectTryIt" disabled="true" onclick="boundingRectExecuteCode()">Try it</button><br>
<textarea rows="15" cols="90" id="boundingRectTestCode" spellcheck="false">
var src = cv.imread("boundingRectCanvasInput");
var dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);
cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
cv.threshold(src, src, 177, 200, cv.THRESH_BINARY);
var contours  = new cv.MatVector();
var hierarchy = new cv.Mat();
cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE, [0,0]);
// You can try more different conversion
var rect = cv.boundingRect(contours.get(0));
var contoursColor = new cv.Scalar(255, 255, 255);
var rectangleColor = new cv.Scalar(255, 0, 0);
cv.drawContours(dst, contours, 0, contoursColor, 1, 8, hierarchy, 100, [0,0]);
cv.rectangle(dst, [rect.x,rect.y], [rect.x+rect.width,rect.y+rect.height], rectangleColor, 2, cv.LINE_AA, 0);
cv.imshow("boundingRectCanvasOutput", dst);
src.delete(); dst.delete(); contours.delete(); hierarchy.delete(); rect.delete(); contoursColor.delete(); rectangleColor.delete();
</textarea>
<p class="err" id="boundingRectErr"></p>
</div>
<div id="boundingRectShowcase">
    <div>
        <canvas id="boundingRectCanvasInput"></canvas>
        <canvas id="boundingRectCanvasOutput"></canvas>
    </div>
    <input type="file" id="boundingRectInput" name="file" />
</div>
<script>
function boundingRectExecuteCode() {
    var boundingRectText = document.getElementById("boundingRectTestCode").value;
    try {
        eval(boundingRectText);
        document.getElementById("boundingRectErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("boundingRectErr").innerHTML = err;
    }
}

loadImageToCanvas("LinuxLogo.jpg", "boundingRectCanvasInput");
var boundingRectInputElement = document.getElementById("boundingRectInput");
boundingRectInputElement.addEventListener("change", boundingRectHandleFiles, false);
function boundingRectHandleFiles(e) {
    var boundingRectUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(boundingRectUrl, "boundingRectCanvasInput");
}
</script>
</body>
</p>
<h3>7.b. Rotated Rectangle</h3>
<p>Here, bounding rectangle is drawn with minimum area, so it considers the rotation also.</p>
<p>We use the function: <b><a class="el" href="d3/dc0/group__imgproc__shape.html#ga3d476a3417130ae5154aea421ca7ead9" title="Finds a rotated rectangle of the minimum area enclosing the input 2D point set. ">cv.minAreaRect</a> (points)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input 2D point set.</td></tr>
  </table>
  </dd>
</dl>
<h2>Try it </h2>
<p>Here is a demo. Canvas elements named minAreaRectCanvasInput and minAreaRectCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. And you can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
<style>
canvas {
    border: 1px solid black;
}
</style>
</head>
<body>
<div id="minAreaRectCodeArea">
<h2>Input your code</h2>
<button id="minAreaRectTryIt" disabled="true" onclick="minAreaRectExecuteCode()">Try it</button><br>
<textarea rows="18" cols="90" id="minAreaRectTestCode" spellcheck="false">
var src = cv.imread("minAreaRectCanvasInput");
var dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);
cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
cv.threshold(src, src, 177, 200, cv.THRESH_BINARY);
var contours  = new cv.MatVector();
var hierarchy = new cv.Mat();
cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE, [0,0]);
// You can try more different conversion
var rotatedRect = cv.minAreaRect(contours.get(0));
var vertices = new cv.Point2fVector()
rotatedRect.points(vertices);
var contoursColor = new cv.Scalar(255, 255, 255);
var rectangleColor = new cv.Scalar(255, 0, 0);
cv.drawContours(dst, contours, 0, contoursColor, 1, 8, hierarchy, 100, [0,0]);
// draw rotatedRect
for (var i = 0; i < 4; i++)
    cv.line(dst, vertices.get(i), vertices.get((i + 1) % 4), rectangleColor, 2, cv.LINE_AA, 0);
cv.imshow("minAreaRectCanvasOutput", dst);
src.delete(); dst.delete(); contours.delete(); hierarchy.delete(); rotatedRect.delete(); contoursColor.delete(); rectangleColor.delete();
</textarea>
<p class="err" id="minAreaRectErr"></p>
</div>
<div id="minAreaRectShowcase">
    <div>
        <canvas id="minAreaRectCanvasInput"></canvas>
        <canvas id="minAreaRectCanvasOutput"></canvas>
    </div>
    <input type="file" id="minAreaRectInput" name="file" />
</div>
<script>
function minAreaRectExecuteCode() {
    var minAreaRectText = document.getElementById("minAreaRectTestCode").value;
    try {
        eval(minAreaRectText);
        document.getElementById("minAreaRectErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("minAreaRectErr").innerHTML = err;
    }
}

loadImageToCanvas("LinuxLogo.jpg", "minAreaRectCanvasInput");
var minAreaRectInputElement = document.getElementById("minAreaRectInput");
minAreaRectInputElement.addEventListener("change", minAreaRectHandleFiles, false);
function minAreaRectHandleFiles(e) {
    var minAreaRectUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(minAreaRectUrl, "minAreaRectCanvasInput");
}
</script>
</body>
</p>
<h2>8. Minimum Enclosing Circle </h2>
<p>Next we find the circumcircle of an object using the function <b><a class="el" href="d3/dc0/group__imgproc__shape.html#ga8ce13c24081bbc7151e9326f412190f1" title="Finds a circle of the minimum area enclosing a 2D point set. ">cv.minEnclosingCircle()</a></b>. It is a circle which completely covers the object with minimum area.</p>
<p>We use the functions: <b><a class="el" href="d3/dc0/group__imgproc__shape.html#ga8ce13c24081bbc7151e9326f412190f1" title="Finds a circle of the minimum area enclosing a 2D point set. ">cv.minEnclosingCircle</a> (points, circle)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input 2D point set. </td></tr>
    <tr><td class="paramname">circle</td><td>output circle.</td></tr>
  </table>
  </dd>
</dl>
<p><b><a class="el" href="d6/d6e/group__imgproc__draw.html#gaf10604b069374903dbd0f0488cb43670" title="Draws a circle. ">cv.circle</a> (img, center, radius, color, thickness = 1, lineType = <a class="el" href="d0/de1/group__core.html#ggaf076ef45de481ac96e0ab3dc2c29a777a5d32eda7017db273a37f158e5b51442a" title="8-connected line ">cv.LINE_8</a>, shift = 0)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>image where the circle is drawn. </td></tr>
    <tr><td class="paramname">center</td><td>center of the circle. </td></tr>
    <tr><td class="paramname">radius</td><td>radius of the circle. </td></tr>
    <tr><td class="paramname">color</td><td>circle color. </td></tr>
    <tr><td class="paramname">thickness</td><td>thickness of the circle outline, if positive. Negative thickness means that a filled circle is to be drawn. </td></tr>
    <tr><td class="paramname">lineType</td><td>type of the circle boundary. </td></tr>
    <tr><td class="paramname">shift</td><td>number of fractional bits in the coordinates of the center and in the radius value.</td></tr>
  </table>
  </dd>
</dl>
<h2>Try it </h2>
<p>Here is a demo. Canvas elements named minEnclosingCircleCanvasInput and minEnclosingCircleCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. And you can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
<style>
canvas {
    border: 1px solid black;
}
</style>
</head>
<body>
<div id="minEnclosingCircleCodeArea">
<h2>Input your code</h2>
<button id="minEnclosingCircleTryIt" disabled="true" onclick="minEnclosingCircleExecuteCode()">Try it</button><br>
<textarea rows="18" cols="90" id="minEnclosingCircleTestCode" spellcheck="false">
var src = cv.imread("minEnclosingCircleCanvasInput");
var dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);
cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
cv.threshold(src, src, 177, 200, cv.THRESH_BINARY);
var contours  = new cv.MatVector();
var hierarchy = new cv.Mat();
cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE, [0,0]);
// You can try more different conversion
var circle = new cv.Circle;
cv.minEnclosingCircle (contours.get(0), circle);
var contoursColor = new cv.Scalar(255, 255, 255);
var circleColor = new cv.Scalar(255, 0, 0);
cv.drawContours(dst, contours, 0, contoursColor, 1, 8, hierarchy, 100, [0,0]);
cv.circle(dst, circle.center, circle.radius, circleColor)
cv.imshow("minEnclosingCircleCanvasOutput", dst);
src.delete(); dst.delete(); contours.delete(); hierarchy.delete(); circle.delete(); contoursColor.delete(); circleColor.delete();
</textarea>
<p class="err" id="minEnclosingCircleErr"></p>
</div>
<div id="minEnclosingCircleShowcase">
    <div>
        <canvas id="minEnclosingCircleCanvasInput"></canvas>
        <canvas id="minEnclosingCircleCanvasOutput"></canvas>
    </div>
    <input type="file" id="minEnclosingCircleInput" name="file" />
</div>
<script>
function minEnclosingCircleExecuteCode() {
    var minEnclosingCircleText = document.getElementById("minEnclosingCircleTestCode").value;
    try {
        eval(minEnclosingCircleText);
        document.getElementById("minEnclosingCircleErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("minEnclosingCircleErr").innerHTML = err;
    }
}

loadImageToCanvas("LinuxLogo.jpg", "minEnclosingCircleCanvasInput");
var minEnclosingCircleInputElement = document.getElementById("minEnclosingCircleInput");
minEnclosingCircleInputElement.addEventListener("change", minEnclosingCircleHandleFiles, false);
function minEnclosingCircleHandleFiles(e) {
    var minEnclosingCircleUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(minEnclosingCircleUrl, "minEnclosingCircleCanvasInput");
}
</script>
</body>
</p>
<h2>9. Fitting an Ellipse </h2>
<p>Next one is to fit an ellipse to an object. It returns the rotated rectangle in which the ellipse is inscribed. We use the functions: <b><a class="el" href="d3/dc0/group__imgproc__shape.html#gaf259efaad93098103d6c27b9e4900ffa" title="Fits an ellipse around a set of 2D points. ">cv.fitEllipse</a> (points)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input 2D point set.</td></tr>
  </table>
  </dd>
</dl>
<p><b>cv.ellipse1 (img, box, color, thickness = 1, lineType = <a class="el" href="d0/de1/group__core.html#ggaf076ef45de481ac96e0ab3dc2c29a777a5d32eda7017db273a37f158e5b51442a" title="8-connected line ">cv.LINE_8</a>)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>image. </td></tr>
    <tr><td class="paramname">box</td><td>alternative ellipse representation via RotatedRect. This means that the function draws an ellipse inscribed in the rotated rectangle. </td></tr>
    <tr><td class="paramname">color</td><td>ellipse color. </td></tr>
    <tr><td class="paramname">thickness</td><td>thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn. </td></tr>
    <tr><td class="paramname">lineType</td><td>type of the ellipse boundary.</td></tr>
  </table>
  </dd>
</dl>
<h2>Try it </h2>
<p>Here is a demo. Canvas elements named fitEllipseCanvasInput and fitEllipseCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. And you can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
<style>
canvas {
    border: 1px solid black;
}
</style>
</head>
<body>
<div id="fitEllipseCodeArea">
<h2>Input your code</h2>
<button id="fitEllipseTryIt" disabled="true" onclick="fitEllipseExecuteCode()">Try it</button><br>
<textarea rows="15" cols="90" id="fitEllipseTestCode" spellcheck="false">
var src = cv.imread("fitEllipseCanvasInput");
var dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);
cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
cv.threshold(src, src, 177, 200, cv.THRESH_BINARY);
var contours  = new cv.MatVector();
var hierarchy = new cv.Mat();
cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE, [0,0]);
// You can try more different conversion
var rotatedRect = cv.fitEllipse(contours.get(0));
var contoursColor = new cv.Scalar(255, 255, 255);
var ellipseColor = new cv.Scalar(255, 0, 0);
cv.drawContours(dst, contours, 0, contoursColor, 1, 8, hierarchy, 100, [0,0]);
cv.ellipse1(dst, rotatedRect, ellipseColor, 1, cv.LINE_8);
cv.imshow("fitEllipseCanvasOutput", dst);
src.delete(); dst.delete(); contours.delete(); hierarchy.delete(); rotatedRect.delete(); contoursColor.delete(); ellipseColor.delete();
</textarea>
<p class="err" id="fitEllipseErr"></p>
</div>
<div id="fitEllipseShowcase">
    <div>
        <canvas id="fitEllipseCanvasInput"></canvas>
        <canvas id="fitEllipseCanvasOutput"></canvas>
    </div>
    <input type="file" id="fitEllipseInput" name="file" />
</div>
<script>
function fitEllipseExecuteCode() {
    var fitEllipseText = document.getElementById("fitEllipseTestCode").value;
    try {
        eval(fitEllipseText);
        document.getElementById("fitEllipseErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("fitEllipseErr").innerHTML = err;
    }
}

loadImageToCanvas("LinuxLogo.jpg", "fitEllipseCanvasInput");
var fitEllipseInputElement = document.getElementById("fitEllipseInput");
fitEllipseInputElement.addEventListener("change", fitEllipseHandleFiles, false);
function fitEllipseHandleFiles(e) {
    var fitEllipseUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(fitEllipseUrl, "fitEllipseCanvasInput");
}
</script>
</body>
</p>
<h2>10. Fitting a Line </h2>
<p>Similarly we can fit a line to a set of points. We can approximate a straight line to it.</p>
<p>We use the functions: <b><a class="el" href="d3/dc0/group__imgproc__shape.html#gaf849da1fdafa67ee84b1e9a23b93f91f" title="Fits a line to a 2D or 3D point set. ">cv.fitLine</a> (points, line, distType, param, reps, aeps)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>input 2D point set. </td></tr>
    <tr><td class="paramname">line</td><td>output line parameters. It should be a Mat of 4 elements[vx, vy, x0, y0], where [vx, vy] is a normalized vector collinear to the line and [x0, y0] is a point on the line. </td></tr>
    <tr><td class="paramname">distType</td><td>distance used by the M-estimator(see <a class="el" href="d7/d1b/group__imgproc__misc.html#gaa2bfbebbc5c320526897996aafa1d8eb">cv.DistanceTypes</a>). </td></tr>
    <tr><td class="paramname">param</td><td>numerical parameter ( C ) for some types of distances. If it is 0, an optimal value is chosen. </td></tr>
    <tr><td class="paramname">reps</td><td>sufficient accuracy for the radius (distance between the coordinate origin and the line). </td></tr>
    <tr><td class="paramname">aeps</td><td>sufficient accuracy for the angle. 0.01 would be a good default value for reps and aeps.</td></tr>
  </table>
  </dd>
</dl>
<p><b><a class="el" href="d6/d6e/group__imgproc__draw.html#ga7078a9fae8c7e7d13d24dac2520ae4a2" title="Draws a line segment connecting two points. ">cv.line</a> (img, pt1, pt2, color, thickness = 1, lineType = <a class="el" href="d0/de1/group__core.html#ggaf076ef45de481ac96e0ab3dc2c29a777a5d32eda7017db273a37f158e5b51442a" title="8-connected line ">cv.LINE_8</a>, shift = 0)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>image. </td></tr>
    <tr><td class="paramname">pt1</td><td>first point of the line segment. </td></tr>
    <tr><td class="paramname">pt2</td><td>second point of the line segment. </td></tr>
    <tr><td class="paramname">color</td><td>line color. </td></tr>
    <tr><td class="paramname">thickness</td><td>line thickness. </td></tr>
    <tr><td class="paramname">lineType</td><td>type of the line,. </td></tr>
    <tr><td class="paramname">shift</td><td>number of fractional bits in the point coordinates.</td></tr>
  </table>
  </dd>
</dl>
<h2>Try it </h2>
<p>Here is a demo. Canvas elements named fitLineCanvasInput and fitLineCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. And you can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
<style>
canvas {
    border: 1px solid black;
}
</style>
</head>
<body>
<div id="fitLineCodeArea">
<h2>Input your code</h2>
<button id="fitLineTryIt" disabled="true" onclick="fitLineExecuteCode()">Try it</button><br>
<textarea rows="19" cols="90" id="fitLineTestCode" spellcheck="false">
var src = cv.imread("fitLineCanvasInput");
var dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);
cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
cv.threshold(src, src, 177, 200, cv.THRESH_BINARY);
var contours  = new cv.MatVector();
var hierarchy = new cv.Mat();
var line = new cv.Mat();
cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE, [0,0]);
// You can try more different conversion
cv.fitLine(contours.get(0), line, cv.DIST_L2, 0, 0.01, 0.01);
var contoursColor = new cv.Scalar(255, 255, 255);
var lineColor = new cv.Scalar(255, 0, 0);
cv.drawContours(dst, contours, 0, contoursColor, 1, 8, hierarchy, 100, [0,0]);
var vx= line.data32f()[0], vy = line.data32f()[1]; x = line.data32f()[2], y = line.data32f()[3];
var lefty = Math.round((-x * vy / vx) + y);
var righty = Math.round(((src.cols - x) * vy / vx) + y);
cv.line(dst, [src.cols - 1, righty], [0, lefty], lineColor, 2, cv.LINE_AA, 0);
cv.imshow("fitLineCanvasOutput", dst);
src.delete(); dst.delete(); contours.delete(); hierarchy.delete(); line.delete(); lineColor.delete(); contoursColor.delete();
</textarea>
<p class="err" id="fitLineErr"></p>
</div>
<div id="fitLineShowcase">
    <div>
        <canvas id="fitLineCanvasInput"></canvas>
        <canvas id="fitLineCanvasOutput"></canvas>
    </div>
    <input type="file" id="fitLineInput" name="file" />
</div>
<script>
function fitLineExecuteCode() {
    var fitLineText = document.getElementById("fitLineTestCode").value;
    try {
        eval(fitLineText);
        document.getElementById("fitLineErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("fitLineErr").innerHTML = err;
    }
}

loadImageToCanvas("LinuxLogo.jpg", "fitLineCanvasInput");
var fitLineInputElement = document.getElementById("fitLineInput");
fitLineInputElement.addEventListener("change", fitLineHandleFiles, false);
function fitLineHandleFiles(e) {
    var fitLineUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(fitLineUrl, "fitLineCanvasInput");
}
function onReady() {
    document.getElementById("momentsTryIt").disabled = false;
    document.getElementById("areaTryIt").disabled = false;
    document.getElementById("perimeterTryIt").disabled = false;
    document.getElementById("approxPolyDPTryIt").disabled = false;
    document.getElementById("convexHullTryIt").disabled = false;
    document.getElementById("boundingRectTryIt").disabled = false;
    document.getElementById("fitEllipseTryIt").disabled = false;
    document.getElementById("minAreaRectTryIt").disabled = false;
    document.getElementById("fitLineTryIt").disabled = false;
    document.getElementById("minEnclosingCircleTryIt").disabled = false;
}
if (typeof cv !== 'undefined') {
    onReady();
} else {
    document.getElementById("opencvjs").onload = onReady;
}
</script>
</body>
 </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 2 2017 14:50:40 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
<script type="text/javascript">
//<![CDATA[
function addButton(label, buttonName) {
    var b = document.createElement("BUTTON");
    b.innerHTML = buttonName;
    b.setAttribute('class', 'toggleable_button label_' + label);
    b.onclick = function() {
        $('.toggleable_button').css({
            border: '2px outset',
            'border-radius': '4px'
        });
        $('.toggleable_button.label_' + label).css({
            border: '2px inset',
            'border-radius': '4px'
        });
        $('.toggleable_div').css('display', 'none');
        $('.toggleable_div.label_' + label).css('display', 'block');
    };
    b.style.border = '2px outset';
    b.style.borderRadius = '4px';
    b.style.margin = '2px';
    return b;
}
function buttonsToAdd($elements, $heading, $type) {
    if ($elements.length === 0) {
        $elements = $("" + $type + ":contains(" + $heading.html() + ")").parent().prev("div.newInnerHTML");
    }
    var arr = jQuery.makeArray($elements);
    var seen = {};
    arr.forEach(function(e) {
        var txt = e.innerHTML;
        if (!seen[txt]) {
            $button = addButton(e.title, txt);
            if (Object.keys(seen).length == 0) {
                var linebreak1 = document.createElement("br");
                var linebreak2 = document.createElement("br");
                ($heading).append(linebreak1);
                ($heading).append(linebreak2);
            }
            ($heading).append($button);
            seen[txt] = true;
        }
    });
    return;
}
$("h2").each(function() {
    $heading = $(this);
    $smallerHeadings = $(this).nextUntil("h2").filter("h3").add($(this).nextUntil("h2").find("h3"));
    if ($smallerHeadings.length) {
        $smallerHeadings.each(function() {
            var $elements = $(this).nextUntil("h3").filter("div.newInnerHTML");
            buttonsToAdd($elements, $(this), "h3");
        });
    } else {
        var $elements = $(this).nextUntil("h2").filter("div.newInnerHTML");
        buttonsToAdd($elements, $heading, "h2");
    }
});
$(".toggleable_button").first().click();
var $clickDefault = $('.toggleable_button.label_python').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
$clickDefault = $('.toggleable_button.label_cpp').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
//]]>
</script>
</body>
</html>
