<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenCV: Geometric Transformations of Images</title>
<link href="opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">3.2.0-dev</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<script type="text/javascript">
//<![CDATA[
function getLabelName(innerHTML) {
    var str = innerHTML.toLowerCase();
    // Replace all '+' with 'p'
    str = str.split('+').join('p');
    // Replace all ' ' with '_'
    str = str.split(' ').join('_');
    // Replace all '#' with 'sharp'
    str = str.split('#').join('sharp');
    // Replace other special characters with 'ascii' + code
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (!(charCode == 95 || (charCode > 96 && charCode < 123) || (charCode > 47 && charCode < 58)))
            str = str.substr(0, i) + 'ascii' + charCode + str.substr(i + 1);
    }
    return str;
}
function addToggle() {
    var $getDiv = $('div.newInnerHTML').last();
    var buttonName = $getDiv.html();
    var label = getLabelName(buttonName.trim());
    $getDiv.attr("title", label);
    $getDiv.hide();
    $getDiv = $getDiv.next();
    $getDiv.attr("class", "toggleable_div label_" + label);
    $getDiv.hide();
}
//]]>
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="tutorial_js_root.html">OpenCV-JavaScript Tutorials</a></li><li class="navelem"><a class="el" href="tutorial_js_table_of_contents_imgproc.html">Image Processing in OpenCV</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Geometric Transformations of Images </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Goals </h2>
<ul>
<li>Learn to apply different geometric transformation to images like translation, rotation, affine transformation etc.</li>
<li>You will see these functions: <b><a class="el" href="da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d" title="Resizes an image. ">cv.resize</a></b>, <b><a class="el" href="da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983" title="Applies an affine transformation to an image. ">cv.warpAffine</a></b>, <b><a class="el" href="da/d54/group__imgproc__transform.html#ga8f6d378f9f8eebb5cb55cd3ae295a999" title="Calculates an affine transform from three pairs of the corresponding points. ">cv.getAffineTransform</a></b> and <b><a class="el" href="da/d54/group__imgproc__transform.html#gaf73673a7e8e18ec6963e3774e6a94b87" title="Applies a perspective transformation to an image. ">cv.warpPerspective</a></b></li>
</ul>
<h2>Transformations </h2>
<h3>Scaling</h3>
<p>Scaling is just resizing of the image. OpenCV comes with a function <b><a class="el" href="da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d" title="Resizes an image. ">cv.resize()</a></b> for this purpose. The size of the image can be specified manually, or you can specify the scaling factor. Different interpolation methods are used. Preferable interpolation methods are <b>cv.InterpolationFlags.INTER_AREA.value</b> for shrinking and <b>cv.InterpolationFlags.INTER_CUBIC.value</b> (slow) &amp; <b>cv.InterpolationFlags.INTER_LINEAR.value</b> for zooming.</p>
<p>We use the function: <b>cv.resize(src, dst, dsize, fx, fy, interpolation)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>input image </td></tr>
    <tr><td class="paramname">dst</td><td>output image; it has the size dsize (when it is non-zero) or the size computed from src.size(), fx, and fy; the type of dst is the same as of src. </td></tr>
    <tr><td class="paramname">dsize</td><td>output image size; if it equals zero, it is computed as: <p class="formulaDsp">
\[𝚍𝚜𝚒𝚣𝚎 = 𝚂𝚒𝚣𝚎(𝚛𝚘𝚞𝚗𝚍(𝚏𝚡*𝚜𝚛𝚌.𝚌𝚘𝚕𝚜), 𝚛𝚘𝚞𝚗𝚍(𝚏𝚢*𝚜𝚛𝚌.𝚛𝚘𝚠𝚜))\]
</p>
 Either dsize or both fx and fy must be non-zero. </td></tr>
    <tr><td class="paramname">fx</td><td>scale factor along the horizontal axis; when it equals 0, it is computed as <p class="formulaDsp">
\[(𝚍𝚘𝚞𝚋𝚕𝚎)𝚍𝚜𝚒𝚣𝚎.𝚠𝚒𝚍𝚝𝚑/𝚜𝚛𝚌.𝚌𝚘𝚕𝚜\]
</p>
</td></tr>
    <tr><td class="paramname">fy</td><td>scale factor along the vertical axis; when it equals 0, it is computed as <p class="formulaDsp">
\[(𝚍𝚘𝚞𝚋𝚕𝚎)𝚍𝚜𝚒𝚣𝚎.𝚑𝚎𝚒𝚐𝚑𝚝/𝚜𝚛𝚌.𝚛𝚘𝚠𝚜\]
</p>
 </td></tr>
    <tr><td class="paramname">interpolation</td><td>interpolation method</td></tr>
  </table>
  </dd>
</dl>
<h2>Try it </h2>
<p>Here is a demo. Canvas elements named resizeCanvasInput and resizeCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. And you can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
<style>
canvas {
    border: 1px solid black;
}
</style>
</head>
<body>
<div id="resizeCodeArea">
<h2>Input your code</h2>
<button id="resizeTryIt" disabled="true" onclick="resizeExecuteCode()">Try it</button><br>
<textarea rows="8" cols="80" id="resizeTestCode" spellcheck="false">
var src = cv.imread("resizeCanvasInput");
var dst = new cv.Mat();
// You can try more different conversion
cv.resize(src, dst, [600,600], 0, 0, cv.InterpolationFlags.INTER_LINEAR.value);
cv.imshow("resizeCanvasOutput", dst);
src.delete();
dst.delete();
</textarea>
</div>
<div id="resizeShowcase">
    <div>
        <canvas id="resizeCanvasInput"></canvas>
        <canvas id="resizeCanvasOutput"></canvas>
    </div>
    <input type="file" id="resizeInput" name="file" />
</div>
<script src="utils.js"></script>
<script async src="opencv.js" id="opencvjs"></script>
<script>
function resizeExecuteCode() {
    var resizeText = document.getElementById("resizeTestCode").value;
    eval(resizeText);
}

loadImageToCanvas("lena.jpg", "resizeCanvasInput");
var resizeInputElement = document.getElementById("resizeInput");
resizeInputElement.addEventListener("change", resizeHandleFiles, false);
function resizeHandleFiles(e) {
    var resizeUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(resizeUrl, "resizeCanvasInput");
}
</script>
</body>
</p>
<h3>Translation</h3>
<p>Translation is the shifting of object's location. If you know the shift in (x,y) direction, let it be \((t_x,t_y)\), you can create the transformation matrix \(\textbf{M}\) as follows:</p>
<p class="formulaDsp">
\[M = \begin{bmatrix} 1 &amp; 0 &amp; t_x \\ 0 &amp; 1 &amp; t_y \end{bmatrix}\]
</p>
<p>We use the function: <b>cv.warpAffine(src, dst, M, dsize, flags, borderMode, borderValue)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>input image. </td></tr>
    <tr><td class="paramname">dst</td><td>output image that has the size dsize and the same type as src. </td></tr>
    <tr><td class="paramname">Mat</td><td>2×3transformation matrix. </td></tr>
    <tr><td class="paramname">dsize</td><td>size of the output image. </td></tr>
    <tr><td class="paramname">flags</td><td>combination of interpolation methods and the optional flag WARP_INVERSE_MAP that means that M is the inverse transformation ( 𝚍𝚜𝚝→𝚜𝚛𝚌 ) </td></tr>
    <tr><td class="paramname">borderMode</td><td>pixel extrapolation method; when borderMode=BORDER_TRANSPARENT, it means that the pixels in the destination image corresponding to the "outliers" in the source image are not modified by the function. </td></tr>
    <tr><td class="paramname">borderValue</td><td>value used in case of a constant border</td></tr>
  </table>
  </dd>
</dl>
<p><b>warning</b></p>
<p>Third argument of the <b><a class="el" href="da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983" title="Applies an affine transformation to an image. ">cv.warpAffine()</a></b> function is the size of the output image, which should be in the form of (width, height). Remember width = number of columns, and height = number of rows.</p>
<h2>Try it </h2>
<p>Here is a demo. Canvas elements named warpAffineCanvasInput and warpAffineCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. And you can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
<style>
canvas {
    border: 1px solid black;
}
</style>
</head>
<body>
<div id="warpAffineCodeArea">
<h2>Input your code</h2>
<button id="warpAffineTryIt" disabled="true" onclick="warpAffineExecuteCode()">Try it</button><br>
<textarea rows="10" cols="80" id="warpAffineTestCode" spellcheck="false">
var src = cv.imread("warpAffineCanvasInput");
var dst = new cv.Mat();
var M = new cv.Mat([2,3], cv.CV_64FC1);
M.data64f()[0]=1; M.data64f()[1]=0; M.data64f()[2]=50;
M.data64f()[3]=0; M.data64f()[4]=1; M.data64f()[5]=100;
// You can try more different conversion
cv.warpAffine(src, dst, M, [src.cols,src.rows], cv.InterpolationFlags.INTER_LINEAR.value, cv.BORDER_CONSTANT, new cv.Scalar());
cv.imshow("warpAffineCanvasOutput", dst);
src.delete(); dst.delete(); M.delete();
</textarea>
</div>
<div id="warpAffineShowcase">
    <div>
        <canvas id="warpAffineCanvasInput"></canvas>
        <canvas id="warpAffineCanvasOutput"></canvas>
    </div>
    <input type="file" id="warpAffineInput" name="file" />
</div>
<script>
function warpAffineExecuteCode() {
    var warpAffineText = document.getElementById("warpAffineTestCode").value;
    eval(warpAffineText);
}

loadImageToCanvas("lena.jpg", "warpAffineCanvasInput");
var warpAffineInputElement = document.getElementById("warpAffineInput");
warpAffineInputElement.addEventListener("change", warpAffineHandleFiles, false);
function warpAffineHandleFiles(e) {
    var warpAffineUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(warpAffineUrl, "warpAffineCanvasInput");
}
</script>
</body>
</p>
<h3>Rotation</h3>
<p>Rotation of an image for an angle \(\theta\) is achieved by the transformation matrix of the form</p>
<p class="formulaDsp">
\[M = \begin{bmatrix} cos\theta &amp; -sin\theta \\ sin\theta &amp; cos\theta \end{bmatrix}\]
</p>
<p>But OpenCV provides scaled rotation with adjustable center of rotation so that you can rotate at any location you prefer. Modified transformation matrix is given by</p>
<p class="formulaDsp">
\[\begin{bmatrix} \alpha &amp; \beta &amp; (1- \alpha ) \cdot center.x - \beta \cdot center.y \\ - \beta &amp; \alpha &amp; \beta \cdot center.x + (1- \alpha ) \cdot center.y \end{bmatrix}\]
</p>
<p>where:</p>
<p class="formulaDsp">
\[\begin{array}{l} \alpha = scale \cdot \cos \theta , \\ \beta = scale \cdot \sin \theta \end{array}\]
</p>
<p>We use the function: <b>cv.warpAffine(src, dst, M, dsize, flags, borderMode, borderValue)</b></p>
<h2>Try it </h2>
<p>Here is a demo. Canvas elements named rotateWarpAffineCanvasInput and rotateWarpAffineCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. And you can change the code in the textbox to investigate more.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="da/d54/group__imgproc__transform.html#gafbbc470ce83812914a70abfb604f4326" title="Calculates an affine matrix of 2D rotation. ">cv.getRotationMatrix2D()</a> should be in the white list to simplify the operation.</dd></dl>
<p> 
<!DOCTYPE html>
<head>
<style>
canvas {
    border: 1px solid black;
}
</style>
</head>
<body>
<div id="rotateWarpAffineCodeArea">
<h2>Input your code</h2>
<button id="rotateWarpAffineTryIt" disabled="true" onclick="rotateWarpAffineExecuteCode()">Try it</button><br>
<textarea rows="18" cols="80" id="rotateWarpAffineTestCode" spellcheck="false">
var src = cv.imread("rotateWarpAffineCanvasInput");
var dst = new cv.Mat(src.cols, src.rows, src.type());
var M = new cv.Mat([2,3], cv.CV_64FC1);
var degree = 45;
var angle = degree * Math.PI / 180.;
var alpha = Math.cos(angle);
var beta = Math.sin(angle);
M.data64f()[0] = alpha,
M.data64f()[1] = beta,
M.data64f()[2] = (1 - alpha) * src.cols / 2 - beta * src.rows / 2,
M.data64f()[3] = -beta,
M.data64f()[4] = alpha,
M.data64f()[5] = beta * src.cols / 2 + (1 - alpha) * src.rows / 2;
// You can try more different conversion
cv.warpAffine(src, dst, M, [src.cols,src.rows], cv.InterpolationFlags.INTER_LINEAR.value, cv.BORDER_CONSTANT, new cv.Scalar());
cv.imshow("rotateWarpAffineCanvasOutput", dst);
src.delete(); dst.delete(); M.delete();
</textarea>
</div>
<div id="rotateWarpAffineShowcase">
    <div>
        <canvas id="rotateWarpAffineCanvasInput"></canvas>
        <canvas id="rotateWarpAffineCanvasOutput"></canvas>
    </div>
    <input type="file" id="rotateWarpAffineInput" name="file" />
</div>
<script>
function rotateWarpAffineExecuteCode() {
    var rotateWarpAffineText = document.getElementById("rotateWarpAffineTestCode").value;
    eval(rotateWarpAffineText);
}

loadImageToCanvas("lena.jpg", "rotateWarpAffineCanvasInput");
var rotateWarpAffineInputElement = document.getElementById("rotateWarpAffineInput");
rotateWarpAffineInputElement.addEventListener("change", rotateWarpAffineHandleFiles, false);
function rotateWarpAffineHandleFiles(e) {
    var rotateWarpAffineUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(rotateWarpAffineUrl, "rotateWarpAffineCanvasInput");
}

</script>
</body>
</p>
<h3>Affine Transformation</h3>
<p>In affine transformation, all parallel lines in the original image will still be parallel in the output image. To find the transformation matrix, we need three points from input image and their corresponding locations in output image. Then <b><a class="el" href="da/d54/group__imgproc__transform.html#ga8f6d378f9f8eebb5cb55cd3ae295a999" title="Calculates an affine transform from three pairs of the corresponding points. ">cv.getAffineTransform</a></b> will create a 2x3 matrix which is to be passed to <b><a class="el" href="da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983" title="Applies an affine transformation to an image. ">cv.warpAffine</a></b>.</p>
<p>We use the function: <b>cv.getAffineTransform(src, dst)</b> and <b>cv.warpAffine(src, dst, M, dsize, flags, borderMode, borderValue)</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>three points from input imag </td></tr>
    <tr><td class="paramname">dst</td><td>three corresponding points in output image</td></tr>
  </table>
  </dd>
</dl>
<h2>Try it </h2>
<p>Here is a demo. Canvas elements named getAffineTransformCanvasInput and getAffineTransformCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. And you can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
<style>
canvas {
    border: 1px solid black;
}
</style>
</head>
<body>
<div id="getAffineTransformCodeArea">
<h2>Input your code</h2>
<button id="getAffineTransformTryIt" disabled="true" onclick="getAffineTransformExecuteCode()">Try it</button><br>
<textarea rows="18" cols="80" id="getAffineTransformTestCode" spellcheck="false">
var src = cv.imread("getAffineTransformCanvasInput");
var dst = new cv.Mat(src.cols, src.rows, src.type());
var srcTri = new cv.Mat(3, 2, cv.CV_32F); 
var dstTri = new cv.Mat(3, 2, cv.CV_32F);
srcTri.data32f()[0] = 0; dstTri.data32f()[0] = 0.6;//(data32f()[0],data32f()[1]) is the first point
srcTri.data32f()[1] = 0; dstTri.data32f()[1] = 0.2;
srcTri.data32f()[2] = 0; dstTri.data32f()[2] = 0.1;//(data32f()[0],data32f()[1]) is the sescond point
srcTri.data32f()[3] = 1; dstTri.data32f()[3] = 1.3;
srcTri.data32f()[4] = 1; dstTri.data32f()[4] = 1.5;//(data32f()[0],data32f()[1]) is the third point
srcTri.data32f()[5] = 0; dstTri.data32f()[5] = 0.3;
var M = new cv.Mat([2,3], cv.CV_64FC1);
M = cv.getAffineTransform(srcTri, dstTri);
// You can try more different conversion
cv.warpAffine(src, dst, M, [src.cols,src.rows], cv.InterpolationFlags.INTER_LINEAR.value, cv.BORDER_CONSTANT, new cv.Scalar());
cv.imshow("getAffineTransformCanvasOutput", dst);
src.delete(); dst.delete(); M.delete(); srcTri.delete(); dstTri.delete();
</textarea>
</div>
<div id="getAffineTransformShowcase">
    <div>
        <canvas id="getAffineTransformCanvasInput"></canvas>
        <canvas id="getAffineTransformCanvasOutput"></canvas>
    </div>
    <input type="file" id="getAffineTransformInput" name="file" />
</div>
<script>
function getAffineTransformExecuteCode() {
    var getAffineTransformText = document.getElementById("getAffineTransformTestCode").value;
    eval(getAffineTransformText);
}

loadImageToCanvas("lena.jpg", "getAffineTransformCanvasInput");
var getAffineTransformInputElement = document.getElementById("getAffineTransformInput");
getAffineTransformInputElement.addEventListener("change", getAffineTransformHandleFiles, false);
function getAffineTransformHandleFiles(e) {
    var getAffineTransformUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(getAffineTransformUrl, "getAffineTransformCanvasInput");
}
</script>
</body>
</p>
<h3>Perspective Transformation</h3>
<p>For perspective transformation, you need a 3x3 transformation matrix. Straight lines will remain straight even after the transformation. Apply <b><a class="el" href="da/d54/group__imgproc__transform.html#gaf73673a7e8e18ec6963e3774e6a94b87" title="Applies a perspective transformation to an image. ">cv.warpPerspective</a></b> with this 3x3 transformation matrix.</p>
<p>We use the function: <b>cv.warpPerspective(src, dst, M, dsize, flags, borderMode, borderValue)</b></p>
<p>The parameters of <a class="el" href="da/d54/group__imgproc__transform.html#gaf73673a7e8e18ec6963e3774e6a94b87" title="Applies a perspective transformation to an image. ">cv.warpPerspective()</a> are similar to the parameters of <a class="el" href="da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983" title="Applies an affine transformation to an image. ">cv.warpAffine()</a>.</p>
<h2>Try it </h2>
<p>Here is a demo. Canvas elements named warpPerspectiveCanvasInput and warpPerspectiveCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. And you can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
<style>
canvas {
    border: 1px solid black;
}
</style>
</head>
<body>
<div id="warpPerspectiveCodeArea">
<h2>Input your code</h2>
<button id="warpPerspectiveTryIt" disabled="true" onclick="warpPerspectiveExecuteCode()">Try it</button><br>
<textarea rows="11" cols="80" id="warpPerspectiveTestCode" spellcheck="false">
var src = cv.imread("warpPerspectiveCanvasInput");
var dst = new cv.Mat();
var M = new cv.Mat([3,3], cv.CV_64FC1);
M.data64f()[0]=1;M.data64f()[1]=0.1;M.data64f()[2]=-65;
M.data64f()[3]=0;M.data64f()[4]=1.1;M.data64f()[5]=-75;
M.data64f()[6]=0;M.data64f()[7]=0;  M.data64f()[8]=1;
// You can try more different conversion
cv.warpPerspective(src, dst, M, [src.cols,src.rows], cv.InterpolationFlags.INTER_LINEAR.value, cv.BORDER_CONSTANT, new cv.Scalar());
cv.imshow("warpPerspectiveCanvasOutput", dst);
src.delete(); dst.delete(); M.delete();
</textarea>
</div>
<div id="warpPerspectiveShowcase">
    <div>
        <canvas id="warpPerspectiveCanvasInput"></canvas>
        <canvas id="warpPerspectiveCanvasOutput"></canvas>
    </div>
    <input type="file" id="warpPerspectiveInput" name="file" />
</div>
<script>
function warpPerspectiveExecuteCode() {
    var warpPerspectiveText = document.getElementById("warpPerspectiveTestCode").value;
    eval(warpPerspectiveText);
}

loadImageToCanvas("lena.jpg", "warpPerspectiveCanvasInput");
var warpPerspectiveInputElement = document.getElementById("warpPerspectiveInput");
warpPerspectiveInputElement.addEventListener("change", warpPerspectiveHandleFiles, false);
function warpPerspectiveHandleFiles(e) {
    var warpPerspectiveUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(warpPerspectiveUrl, "warpPerspectiveCanvasInput");

}
document.getElementById("opencvjs").onload = function() {
    document.getElementById("resizeTryIt").disabled = false;
    document.getElementById("warpAffineTryIt").disabled = false;
    document.getElementById("rotateWarpAffineTryIt").disabled = false;
    document.getElementById("getAffineTransformTryIt").disabled = false;
    document.getElementById("warpPerspectiveTryIt").disabled = false;
};
</script>
</body>
</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="da/d54/group__imgproc__transform.html#ga8c1ae0e3589a9d77fffc962c49b22043" title="returns 3x3 perspective transformation for the corresponding 4 point pairs. ">cv.getPerspectiveTransform()</a> should be in the white list to find the transformation matrix from 4 points on the input image and corresponding points on the output image. </dd></dl>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 14 2017 10:00:33 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
<script type="text/javascript">
//<![CDATA[
function addButton(label, buttonName) {
    var b = document.createElement("BUTTON");
    b.innerHTML = buttonName;
    b.setAttribute('class', 'toggleable_button label_' + label);
    b.onclick = function() {
        $('.toggleable_button').css({
            border: '2px outset',
            'border-radius': '4px'
        });
        $('.toggleable_button.label_' + label).css({
            border: '2px inset',
            'border-radius': '4px'
        });
        $('.toggleable_div').css('display', 'none');
        $('.toggleable_div.label_' + label).css('display', 'block');
    };
    b.style.border = '2px outset';
    b.style.borderRadius = '4px';
    b.style.margin = '2px';
    return b;
}
function buttonsToAdd($elements, $heading, $type) {
    if ($elements.length === 0) {
        $elements = $("" + $type + ":contains(" + $heading.html() + ")").parent().prev("div.newInnerHTML");
    }
    var arr = jQuery.makeArray($elements);
    var seen = {};
    arr.forEach(function(e) {
        var txt = e.innerHTML;
        if (!seen[txt]) {
            $button = addButton(e.title, txt);
            if (Object.keys(seen).length == 0) {
                var linebreak1 = document.createElement("br");
                var linebreak2 = document.createElement("br");
                ($heading).append(linebreak1);
                ($heading).append(linebreak2);
            }
            ($heading).append($button);
            seen[txt] = true;
        }
    });
    return;
}
$("h2").each(function() {
    $heading = $(this);
    $smallerHeadings = $(this).nextUntil("h2").filter("h3").add($(this).nextUntil("h2").find("h3"));
    if ($smallerHeadings.length) {
        $smallerHeadings.each(function() {
            var $elements = $(this).nextUntil("h3").filter("div.newInnerHTML");
            buttonsToAdd($elements, $(this), "h3");
        });
    } else {
        var $elements = $(this).nextUntil("h2").filter("div.newInnerHTML");
        buttonsToAdd($elements, $heading, "h2");
    }
});
$(".toggleable_button").first().click();
var $clickDefault = $('.toggleable_button.label_python').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
$clickDefault = $('.toggleable_button.label_cpp').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
//]]>
</script>
</body>
</html>
